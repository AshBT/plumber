#!/usr/bin/env python
import argparse
import sys
import logging
import inspect
import textwrap
# the import fails when our environment variables aren't properly set
try:
    import plugins.enhancer
except KeyError as e:
    print "Unable to obtain environment variable", e
    print "Reminder: Source your secret.sh file with usernames and passwords for SQL, Neo4j, etc."
    sys.exit()

if __name__ == "__main__":
    # dynamically import the enhancers
    enhancer_list = []
    for key in plugins.__all__:
        # the modules live at the top level of plugins.__all__
        module = plugins.__dict__[key]
        for k in module.__dict__:
            # for each element in the module, we check if it's a class
            # and if it's a subclass of Enhancer; if it is, we add it
            # to the plugins.__dict__ (exposing it via, for instance,
            # plugins.MyEnhancerName) and also add it to the enhancer
            # list (for display if needed)
            obj = module.__dict__[k]
            if inspect.isclass(obj) and issubclass(obj, plugins.enhancer.Enhancer):
                plugins.__dict__[k] = obj
                enhancer_list.append(obj.__name__)

    parser = argparse.ArgumentParser(prog="enhance",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    description=textwrap.dedent("""
Enhance base Neo4j data. This code works by invoking a series of
enhancers in order. This means that *dependencies* between the enhancers
matter.

For instance, if one enhancer adds twitter handles and another uses the
Twitter handles to do more work, then you must invoke the first enhancer
before the second, e.g.,
    ./enhance AddTwitter TwitterEnhancer
This is in contrast to `./enhance TwitterEnhancer AddTwitter`, which
will do nothing.

available enhancers:
  {enhancers}
        """.format(enhancers="\n  ".join(enhancer_list))), epilog="Happy enhancing!")
    parser.add_argument("enhancer", nargs='+', help="a list of enhancers to run over the data")
    parser.add_argument("-v", "--verbosity", action="count", default=0, help="increase output verbosity")
    parser.add_argument("--start", type=int, default=0, help="which row to start")
    parser.add_argument("--stop", type=int, default=0, help="which row to stop")
    args = parser.parse_args()

    if args.verbosity >= 3:
        # dumps *all* debug info
        logging.basicConfig(level=logging.DEBUG)
    if args.verbosity >= 2:
        link_log = logging.getLogger('link')
        link_log.addHandler(logging.StreamHandler())
        link_log.setLevel(logging.DEBUG)
    elif args.verbosity >= 1:
        link_log = logging.getLogger('link')
        link_log.addHandler(logging.StreamHandler())
        link_log.setLevel(logging.INFO)

    # create a class on-the-fly
    class OneTimeEnhancer(plugins.enhancer.Enhancer):
        def __init__(self):
            super(OneTimeEnhancer, self).__init__()
            self.enhancers = []

            for enhancer in args.enhancer:
                if hasattr(plugins, enhancer):
                    enhancer_class = getattr(plugins, enhancer)
                    self.enhancers.append(enhancer_class(graph=self.db))
                else:
                    print("No such enhancer '%s' exists; skipping." % enhancer)


        def cleanup(self):
            for enhancer in self.enhancers:
                enhancer.cleanup()

        def enhance(self, record):
            # it *must* run the enhancers in order!
            for enhancer in self.enhancers:
                enhancer.enhance(record)

    # instantiate the class that runs all the enhancers in sequence
    enhance = OneTimeEnhancer()
    if enhance.enhancers:
        enhance.run(start=args.start, stop=args.stop)
